1.hibernatge.cfg.xml常用配置
	hibernate.show_sql，是否把hibernate运行时的SQL语句输出到控制台
	hibernate.formate_sql，输出到控制台的语句是否排版
	hbm2ddl.auto，可以帮助由java代码生成数据库脚本，进而生产具体的表结构
	hibernate.default_schema，默认的数据库
	hibernate.dialect，配置hibernate数据库方言，hibernate可针对特殊的数据库进行优化

2. session简介
	session是操作数据库的对象，sessin与connection，是多对一关系，每个session都有一个与之对应的connection，一个connection不同时刻可以供多个session使用。
	把对象保存在关系数据库中需要调用session的各种方法，如：save(), update(),delete(), createQuery()等

2.1 session获得
	openSession，getCurrentSession
	如果是getCurrentSession需要在hibernate.cfg.xml文件中进行配置：
	如果是本地事务(jdbc事务)
	<propertyname="hibernate.current_session_context_class">thread</property>
	如果是全局事务(jta事务)
	<propertyname="hibernate.current_session_context_class">jta</property>

3. transactin事务
	hibernate对数据的操作都是封装在事务当中，并且默认是非自动提交的方式。所以用session保存对象的时候，如果不开启事务，并且提交事务，对象并不会真正保存在数据库中。
	如果想让hibernate像jdbc那样自动提交事务，必须调用session对象dowork()方法，获得jdbc的connectin后，设置其为自动提交事务模式。（不推荐）


4. session单表操作的get和load的区别：
	User user = (User)session.load(User.class, 2);
 	load的方式加载对象时，会使用延迟加载机制，此时并不会发出sql语句，只有当我们需要使用的时候才会从数据库中去查询；此时得到的User对象其实是一个代理对象，该代理对象里面仅仅只有id这个属性。如果此时要得到user其他属性，则会从数据库中查询
	
	User user = (User)session.get(User.class, 2);
	通过get方法来加载对象时，不管使不使用该对象，都会发出sql语句，从数据库中查询
	
	当通过get方式试图得到一个id不存在的user对象时，此时会报NullPointException异常。
	当通过load方式试图得到一个id不存在的user对象时，此时会报ObjectNotFoundException异常。
	为什么使用load的方式和get的方式来得到一个不存在的对象报的异常不同呢？？其原因还是因为load的延迟加载机制，使用load时，此时的user对象是一个代理对象，仅仅保存了当前的这个id值，当我们试图得到该对象的username属性时，这个属性其实是不存在的，所以就会报出ObjectNotFoundException这个异常了。
	
	LazyInitializationException异常
	因为load的延迟加载机制，当我们通过load()方法来加载一个对象时，此时并没有发出sql语句去从数据库中查询出该对象，当前这个对象仅仅是一个只有id的代理对象，我们还并没有使用该对象，但是此时我们的session已经关闭了，所以当我们在测试用例中使用该对象时就会报LazyInitializationException这个异常了。所以以后我们只要看到控制台报LazyInitializationException这种异常，就知道是使用了load的方式延迟加载一个对象了，解决这个的方法有两种，一种是将load改成get的方式来得到该对象，另一种是在表示层来开启我们的session和关闭session。
	
	
	
